#!/usr/bin/env ruby

# Configuration Constants
IMAGE_FORMATS = %w[jpeg jpg png tiff avif].freeze

# Width limits for different image types
HERO_MAX_WIDTH = 2880        # Full-bleed hero/cover images
DEFAULT_MAX_WIDTH = 2880 # 1600     # In-article images (single column)
MOBILE_MAX_WIDTH = 1400      # Mobile-specific images

# Keywords for categorizing images (case-insensitive matching)
HERO_KEYWORDS = %w[cover hero large big wide].freeze
MOBILE_KEYWORDS = %w[mobile].freeze

BACKUP_DATE_FORMAT = '%Y-%m-%d'
TARGET_DIRECTORIES = ['images/posts', 'images/pages'].freeze

require 'fileutils'
require 'mini_magick'
require 'date'

class ImageSanitizer
  def initialize(dry_run: false)
    @dry_run = dry_run
    @resized_count = 0
    @skipped_count = 0
    @resized_files = { hero: [], mobile: [], default: [] }
  end

  def run
    puts "Starting image sanitization#{' (DRY RUN)' if @dry_run}..."
    puts "Width limits:"
    puts "  - Hero/Cover images: #{HERO_MAX_WIDTH}px"
    puts "  - Mobile images: #{MOBILE_MAX_WIDTH}px"
    puts "  - Standard images: #{DEFAULT_MAX_WIDTH}px"
    puts "Formats: #{IMAGE_FORMATS.join(', ')}"
    puts

    process_directories
    print_summary
  end

  private

  def determine_target_width(filename)
    basename = File.basename(filename, '.*').downcase

    if MOBILE_KEYWORDS.any? { |keyword| basename.match?(/.*#{keyword}.*/) }
      return { width: MOBILE_MAX_WIDTH, category: :mobile }
    elsif HERO_KEYWORDS.any? { |keyword| basename.match?(/.*#{keyword}.*/) }
      return { width: HERO_MAX_WIDTH, category: :hero }
    else
      return { width: DEFAULT_MAX_WIDTH, category: :default }
    end
  end

  def process_directories
    TARGET_DIRECTORIES.each do |dir|
      next unless Dir.exist?(dir)

      find_images(dir).each do |image_path|
        process_image(image_path)
      end
    end
  end

  def find_images(directory)
    pattern = "#{directory}/**/*.{#{IMAGE_FORMATS.join(',')}}"
    Dir.glob(pattern, File::FNM_CASEFOLD)
  end

  def process_image(image_path)
    image = MiniMagick::Image.open(image_path)
    target = determine_target_width(image_path)

    if needs_resize?(image, target[:width])
      resize_image(image_path, image, target)
    else
      @skipped_count += 1
    end
  rescue MiniMagick::Error => e
    puts "\nError processing #{image_path}: #{e.message}"
    @skipped_count += 1
  end

  def needs_resize?(image, target_width)
    image.width > target_width
  end

  def resize_image(image_path, image, target)
    unless @dry_run
      create_backup(image_path)
      image.resize("#{target[:width]}x")
      image.write(image_path)
    end

    @resized_count += 1
    @resized_files[target[:category]] << image_path
    print '.'
  end

  def create_backup(image_path)
    backup_dir = File.join('tmp', Date.today.strftime(BACKUP_DATE_FORMAT))
    FileUtils.mkdir_p(backup_dir)

    filename = File.basename(image_path)
    backup_path = find_available_backup_path(backup_dir, filename)

    FileUtils.cp(image_path, backup_path)
    backup_path
  end

  def find_available_backup_path(backup_dir, filename)
    base_name = File.basename(filename, '.*')
    extension = File.extname(filename)
    backup_path = File.join(backup_dir, filename)

    return backup_path unless File.exist?(backup_path)

    counter = 2
    loop do
      new_filename = "#{base_name}-#{counter}#{extension}"
      backup_path = File.join(backup_dir, new_filename)
      return backup_path unless File.exist?(backup_path)
      counter += 1
    end
  end

  def print_summary
    puts "\n\n" + "=" * 60
    puts "Summary"
    puts "=" * 60

    if @resized_count > 0
      puts "\nResized #{@resized_count} image(s):"

      if @resized_files[:hero].any?
        puts "\n  Hero/Cover images (#{HERO_MAX_WIDTH}px): #{@resized_files[:hero].count} files"
        @resized_files[:hero].each { |path| puts "    - #{path}" }
      end

      if @resized_files[:mobile].any?
        puts "\n  Mobile images (#{MOBILE_MAX_WIDTH}px): #{@resized_files[:mobile].count} files"
        @resized_files[:mobile].each { |path| puts "    - #{path}" }
      end

      if @resized_files[:default].any?
        puts "\n  Standard images (#{DEFAULT_MAX_WIDTH}px): #{@resized_files[:default].count} files"
        @resized_files[:default].each { |path| puts "    - #{path}" }
      end
    else
      puts "\nNo images needed resizing."
    end

    puts "\nSkipped #{@skipped_count} image(s) (already within size limits or errors)"
    puts "\nTotal processed: #{@resized_count + @skipped_count}"

    if @dry_run
      puts "\n*** DRY RUN - No changes were made ***"
    elsif @resized_count > 0
      backup_dir = File.join('tmp', Date.today.strftime(BACKUP_DATE_FORMAT))
      puts "\nBackups saved to: #{backup_dir}/"
    end

    puts "=" * 60
  end
end

# Script execution
dry_run = ARGV.include?('--dry-run')
ImageSanitizer.new(dry_run: dry_run).run